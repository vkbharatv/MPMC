Timer with Motors — 8051/8052 Timer-based Delays and Stepper Control

Author: Dr Bharat Verma
Date: 2025-10-09

Overview
--------
This small project demonstrates using Timer0 on an 8051/8052 family MCU to generate accurate millisecond and microsecond delays and uses those delays to drive a stepper motor in a simple full-step sequence. The code is written in plain C and expects a classic 8051-style toolchain (Keil µVision is used to produce the existing build artifacts in this repository).

Goal
----
- Provide a reliable 1 ms delay primitive (delay1ms) using Timer0 in 16-bit mode (mode 1).
- Provide a reliable 1 us delay primitive (delay1us) using Timer0 in 8-bit auto-reload mode (mode 2).
- Provide wrappers for multi-ms (`delay(unsigned int ms)`) and multi-us (`delay_us(unsigned int us)`) delays.
- Use those delays to step a stepper motor through a 4-step full-step sequence.

Files in this repository
------------------------
- `main.c` — Application entry. Toggles an LED and calls `stepper_steps()` to drive the motor.
- `delay.h` — Delay primitives implemented with Timer0: `delay1ms()`, `delay(unsigned int ms)`, `delay1us()`, `delayT()` and `delay_us(unsigned int us)`. Change the `FOSC` macro here to match your oscillator.
 - `timer51.h` — Delay primitives implemented with Timer0: `delay1ms()`, `delay(unsigned int ms)`, `delay1us()`, and `delay_us(unsigned int us)`. Change the `FOSC` macro here to match your oscillator.
   (Note: `timer51.h` replaces the earlier `delay.h` filename used in older commits/notes.)
- `Objects/`, `Listings/` — Build artifacts generated by the toolchain (object, listing, hex file, etc.).

How the delays work (summary)
-----------------------------
1) Millisecond delay (delay1ms)
   - Uses Timer0 in 16-bit mode (mode 1).
   - Ticks per millisecond = (FOSC / 12) / 1000.
   - Preload value = 65536 - ticks_per_ms.
   - Timer is loaded with the preload, started, and code waits for overflow (TF0).
   - Works well for reasonable MCU clock speeds (12 MHz typical). The wrapper `delay(unsigned int ms)` calls this repeatedly.

2) Microsecond delay (delay1us)
   - Uses Timer0 in 8-bit auto-reload mode (mode 2) but performs a single overflow by loading TH0/TL0 with a reload value and waiting for TF0 once.
   - Ticks per microsecond = (FOSC / 12) / 1,000,000.
   - Because mode 2 counts 8-bit increments, the code calculates reload = 256 - ticks_per_us so that overflow happens after exactly one instruction-cycle tick (i.e., ~1 us for a 12 MHz crystal).
   - The wrapper `delay_us(unsigned int us)` calls `delay1us()` repeatedly to generate larger microsecond delays.

Timing formula examples (for FOSC = 12 MHz)
-------------------------------------------
- FOSC = 12,000,000 Hz
- Machine-cycle frequency = FOSC / 12 = 1,000,000 Hz (1 tick = 1 microsecond)

For 1 ms delay:
- ticks_per_ms = (FOSC / 12) / 1000 = 1000 ticks
- preload = 65536 - 1000 = 64536 -> TH0/TL0 loaded with 64536
- Timer overflows after 1000 ticks -> ~1 ms

For 1 us delay (mode 2/8-bit):
- ticks_per_us = (FOSC / 12) / 1,000,000 = 1 tick
- reload = 256 - 1 = 255 -> TH0 = TL0 = 255
- Starting from 255, timer overflows after 1 tick -> ~1 us

Important implementation notes & limitations
-------------------------------------------
- The `FOSC` macro in `delay.h` must match your hardware oscillator frequency. The code assumes classic 8051 timing where one machine cycle = 12 oscillator cycles.
- In `delay1us()` the code casts the ticks-per-us into an 8-bit value. If your oscillator frequency is very high such that ticks_per_us > 255, the current implementation will overflow. On typical 8051s (e.g., 12 MHz, 11.0592 MHz) this is not an issue. If using much higher frequencies, change types and algorithm.
- These delay functions are blocking (busy-wait loops). They disable no interrupts explicitly, but because they wait on the TF0 flag, they are not re-entrant and will interfere with other code that expects Timer0. If your application uses Timer0 for other reasons, either:
  - Change these functions to use a different timer; or
  - Rework them to preserve and restore Timer0 state and interrupts; or
  - Use hardware timers in interrupt mode (non-blocking) and a tick counter.
- `delay_us(unsigned int us)` loops `us` times calling `delay1us()`. For large microsecond delays this is inefficient; use coarser delays where possible (e.g., ms-level) or implement a more efficient loop that counts overflows to make long microsecond-scale delays.

Stepper motor control (in `main.c`)
-----------------------------------
- The stepper is driven from `P2`. The sequence `stepper_sequence[]` contains four 4-bit patterns representing full-step (two adjacent coils energized) states.
- `stepper_steps(unsigned int steps)` advances the step index and writes the pattern to `STEPPER_PORT`.
- The code currently calls `delay(STEP_DELAY)` (ms-level) only when the `step_index` wraps back to 0. This means the motor advances `NUM_STEPS` rapidly then delays once per sequence wrap. If you prefer a per-step delay (normal for controlling motor speed smoothly), change the code to call delay per iteration. Example change:

    for (i = 0; i < steps; i++) {
        STEPPER_PORT = stepper_sequence[step_index];
        step_index = (step_index + 1) % NUM_STEPS;
        delay(STEP_DELAY); // per-step delay (milliseconds)
    }

- If you want microsecond-level step timing, replace `delay(STEP_DELAY)` with `delay_us(us_value)` and ensure `STEP_DELAY` or `us_value` is in microseconds.

Build & run
-----------
Recommended: Keil µVision
- Open `timer_motor.uvproj` in Keil µVision and build the project. Keil will produce the hex in `Objects/` (e.g., `timer_motor.hex`).

Alternative: SDCC (community toolchain)
- SDCC can compile 8051 C, but the build/link commands differ and you will need to combine the object output into a hex with the appropriate tools. Example (very rough):
  - sdcc -mmcs51 --no-std-crt -o main.rel main.c
  - sdas8051 or another assembler/linker to produce hex and fuse with crt files; details depend on your toolchain.

Flashing
- Use your usual 8051 programmer and target board to flash the produced HEX. The exact steps depend on your hardware.

Quick tips
----------
- Adjust `FOSC` in `delay.h` to match your crystal/oscillator.
- If you need precise long delays and want to avoid blocking, convert delay routines to use Timer interrupts and a tick counter.
- If you plan to use interrupts while also needing delays, preserve Timer0 state in the delay functions or choose a different timer.

Suggested improvements (low-risk)
--------------------------------
- Make `delay1us()` and `delay1ms()` static inline if the compiler/toolchain supports it to reduce call overhead.
- Add `delay_preserve_timer0()` wrappers that save/restore TMOD/TH0/TL0/TF0/TR0 and disable Timer0 interrupts while the delay runs.
- Add a non-blocking delay API that uses Timer1 or Timer2 interrupt to maintain a millisecond/microsecond tick counter.
- Add unit tests (if using a simulator) or automated smoke tests to verify timing for selected FOSC values.

Contact & license
-----------------
Author: Dr Bharat Verma (bharat.verma@lnmiit.ac.in)
License: Please see individual project or institution policies if you plan to reuse code; otherwise attribute the author and keep modifications documented.

Completion notes
----------------
- This README explains the current repository layout, how delay functions are implemented, how to modify and use them for microsecond and millisecond delays, and how the stepper control uses those delays.
- If you'd like, I can also:
  - Modify `main.c` to use per-step delays (ms or us) instead of delay-on-wrap; or
  - Add a wrapper that preserves Timer0 state for safe use with other code; or
  - Add a small Makefile / SDCC-compatible build script.
